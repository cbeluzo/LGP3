# Oracle Certified Professional, Java SE 8 Programmer (OCPJP 8) - 1Z0-809

## Objetivo da Aula
Esta aula tem como objetivo fornecer um entendimento aprofundado dos conceitos avançados abordados na certificação OCPJP 8, incluindo design de classes, operações com JDBC, concorrência, exceções avançadas, genéricos e coleções, design de classes Java, operações de I/O com NIO.2, manipulação de streams, internacionalização e a API de data/hora do Java SE 8.

---
Sumário

1. **Advanced Class Design**: Herança, polimorfismo, classes abstratas.
2. **Building Database Applications with JDBC**: Conexões JDBC, operações CRUD.
3. **Concurrency**: Threads, sincronização, `java.util.concurrent`.
4. **Exceptions and Assertions**: Exceções avançadas, uso de `assert`.
5. **Generics and Collections**: Uso de genéricos, coleções (`List`, `Set`, `Map`).
6. **Java Class Design**: Design de classes e métodos avançados.
7. **Java File I/O (NIO.2)**: Operações de I/O com a API NIO.
8. **Java Stream API**: Manipulação de streams e lambda expressions.
9. **Localization**: Internacionalização, formatação de data, números.
10. **Java SE 8 Date/Time API**: Manipulação de datas e horários com a nova API【51†source】【52†source】.

---

## 1. Advanced Class Design

**Conceitos**:
- **Herança**: Permite que uma classe (`subclasse`) herde atributos e métodos de outra classe (`superclasse`). Promove reutilização de código e estruturação hierárquica.
- **Polimorfismo**: Habilidade de diferentes classes serem tratadas como instâncias da mesma classe através de uma interface comum. Isso permite que métodos sejam usados de maneira intercambiável.
- **Classes Abstratas**: Classes que não podem ser instanciadas diretamente. Elas são usadas como superclasses para fornecer um comportamento comum a todas as subclasses.
- **Interfaces**: Definem um contrato que outras classes devem seguir. Interfaces permitem múltipla herança de comportamento.

#### Explicação Detalhada

1. **Herança**:
   - **Definição**: Herança é um mecanismo que permite que uma classe derive atributos e comportamentos de outra classe. A subclasse herda os membros (campos e métodos) da superclasse.
   - **Uso do `extends`**: A palavra-chave `extends` é usada para declarar herança em Java.
   - **Exemplo de Herança**:
     ```java
     class Animal {
         public void eat() {
             System.out.println("This animal eats food.");
         }
     }

     class Dog extends Animal {
         public void bark() {
             System.out.println("The dog barks.");
         }
     }

     public class TestAnimal {
         public static void main(String[] args) {
             Dog dog = new Dog();
             dog.eat(); // Herança do método eat da classe Animal
             dog.bark();
         }
     }
     ```

2. **Polimorfismo**:
   - **Definição**: Polimorfismo é a capacidade de uma variável, objeto ou método de tomar várias formas. Em Java, isso é geralmente alcançado através da herança e interfaces.
   - **Sobrecarga de Método**: Definir múltiplos métodos com o mesmo nome, mas diferentes parâmetros.
   - **Sobrescrita de Método**: Substituir a implementação de um método na subclasse.
   - **Exemplo de Polimorfismo**:
     ```java
     class Animal {
         public void makeSound() {
             System.out.println("Animal makes a sound");
         }
     }

     class Dog extends Animal {
         @Override
         public void makeSound() {
             System.out.println("Dog barks");
         }
     }

     class Cat extends Animal {
         @Override
         public void makeSound() {
             System.out.println("Cat meows");
         }
     }

     public class TestPolymorphism {
         public static void main(String[] args) {
             Animal myAnimal = new Dog();
             myAnimal.makeSound(); // Chama o método sobrescrito na classe Dog

             myAnimal = new Cat();
             myAnimal.makeSound(); // Chama o método sobrescrito na classe Cat
         }
     }
     ```

3. **Classes Abstratas**:
   - **Definição**: Classes abstratas não podem ser instanciadas diretamente e são usadas para declarar métodos que devem ser implementados pelas subclasses.
   - **Uso do `abstract`**: A palavra-chave `abstract` é usada para declarar uma classe ou método abstrato.
   - **Exemplo de Classe Abstrata**:
     ```java
     abstract class Animal {
         public abstract void makeSound();

         public void eat() {
             System.out.println("This animal eats food.");
         }
     }

     class Dog extends Animal {
         @Override
         public void makeSound() {
             System.out.println("Dog barks");
         }
     }

     public class TestAbstract {
         public static void main(String[] args) {
             Animal myDog = new Dog();
             myDog.makeSound();
             myDog.eat();
         }
     }
     ```

4. **Interfaces**:
   - **Definição**: Interfaces definem um contrato que outras classes devem seguir. Elas contêm apenas assinaturas de métodos e constantes.
   - **Uso do `implements`**: A palavra-chave `implements` é usada para declarar que uma classe implementa uma interface.
   - **Exemplo de Interface**:
     ```java
     interface Animal {
         void makeSound();
     }

     class Dog implements Animal {
         @Override
         public void makeSound() {
             System.out.println("Dog barks");
         }
     }

     class Cat implements Animal {
         @Override
         public void makeSound() {
             System.out.println("Cat meows");
         }
     }

     public class TestInterface {
         public static void main(String[] args) {
             Animal myDog = new Dog();
             myDog.makeSound();

             Animal myCat = new Cat();
             myCat.makeSound();
         }
     }
     ```

#### Exemplo Completo

**Objetivo**: Demonstrar conceitos de herança, polimorfismo, classes abstratas e interfaces.

```java
abstract class Animal {
    public abstract void makeSound();

    public void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog barks");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Cat meows");
    }
}

interface Pet {
    void play();
}

class Labrador extends Dog implements Pet {
    @Override
    public void play() {
        System.out.println("Labrador plays fetch");
    }
}

public class AdvancedClassDesignExample {
    public static void main(String[] args) {
        Animal myDog = new Labrador();
        myDog.makeSound();
        myDog.eat();

        Pet myPet = new Labrador();
        myPet.play();
    }
}
```

**Exercícios**:
1. **Herança**: Criar uma hierarquia de classes para representar diferentes tipos de veículos, como `Vehicle`, `Car` e `Truck`.
2. **Polimorfismo**: Implementar um método que aceita um parâmetro do tipo `Vehicle` e demonstra o uso de polimorfismo chamando métodos específicos de `Car` e `Truck`.
3. **Classes Abstratas**: Criar uma classe abstrata `Shape` com métodos abstratos `calculateArea` e `calculatePerimeter`, e subclasses `Circle` e `Rectangle` que implementam esses métodos.
4. **Interfaces**: Definir uma interface `Playable` com um método `play` e criar classes `Guitar` e `Piano` que implementam essa interface.
5. **Combinação de Conceitos**: Desenvolver um sistema de gestão de biblioteca com uma classe abstrata `LibraryItem`, subclasses `Book` e `Magazine`, e uma interface `Borrowable` para itens que podem ser emprestados.


## 2. Building Database Applications with JDBC

**Conceitos**:
- **JDBC (Java Database Connectivity)**: É uma API que permite que programas Java se conectem e executem operações em bancos de dados. JDBC fornece uma interface padrão para a execução de instruções SQL, permitindo que os desenvolvedores escrevam código independente do sistema de gerenciamento de banco de dados (SGBD).
- **Conexões JDBC**: Estabelecer uma conexão com o banco de dados.
- **Operações CRUD**: Create, Read, Update, Delete são operações fundamentais para manipulação de dados em um banco de dados.

#### Explicação Detalhada

1. **Estabelecendo uma Conexão JDBC**:
   - **Definição**: Uma conexão JDBC é um link entre uma aplicação Java e um banco de dados, que permite a execução de instruções SQL.
   - **Passos para Estabelecer uma Conexão**:
     - Carregar o driver JDBC.
     - Estabelecer a conexão usando a classe `DriverManager`.
     - Fechar a conexão após o uso.
   - **Exemplo de Estabelecimento de Conexão**:
     ```java
     import java.sql.Connection;
     import java.sql.DriverManager;
     import java.sql.SQLException;

     public class JDBCDemo {
         public static void main(String[] args) {
             String url = "jdbc:mysql://localhost:3306/mydatabase";
             String user = "root";
             String password = "password";

             try {
                 Connection conn = DriverManager.getConnection(url, user, password);
                 System.out.println("Connection established successfully!");
                 conn.close();
             } catch (SQLException e) {
                 e.printStackTrace();
             }
         }
     }
     ```

2. **Operações CRUD com JDBC**:
   - **Create (Inserção de Dados)**:
     - **Definição**: Inserir novos registros no banco de dados.
     - **Exemplo**:
       ```java
       import java.sql.Connection;
       import java.sql.DriverManager;
       import java.sql.PreparedStatement;
       import java.sql.SQLException;

       public class InsertDemo {
           public static void main(String[] args) {
               String url = "jdbc:mysql://localhost:3306/mydatabase";
               String user = "root";
               String password = "password";

               try {
                   Connection conn = DriverManager.getConnection(url, user, password);
                   String sql = "INSERT INTO Customers (name, email) VALUES (?, ?)";
                   PreparedStatement statement = conn.prepareStatement(sql);
                   statement.setString(1, "John Doe");
                   statement.setString(2, "john.doe@example.com");
                   int rowsInserted = statement.executeUpdate();
                   if (rowsInserted > 0) {
                       System.out.println("A new user was inserted successfully!");
                   }
                   conn.close();
               } catch (SQLException e) {
                   e.printStackTrace();
               }
           }
       }
       ```

   - **Read (Leitura de Dados)**:
     - **Definição**: Recuperar dados do banco de dados.
     - **Exemplo**:
       ```java
       import java.sql.Connection;
       import java.sql.DriverManager;
       import java.sql.ResultSet;
       import java.sql.SQLException;
       import java.sql.Statement;

       public class ReadDemo {
           public static void main(String[] args) {
               String url = "jdbc:mysql://localhost:3306/mydatabase";
               String user = "root";
               String password = "password";

               try {
                   Connection conn = DriverManager.getConnection(url, user, password);
                   String sql = "SELECT * FROM Customers";
                   Statement statement = conn.createStatement();
                   ResultSet resultSet = statement.executeQuery(sql);

                   while (resultSet.next()) {
                       int id = resultSet.getInt("id");
                       String name = resultSet.getString("name");
                       String email = resultSet.getString("email");
                       System.out.println("ID: " + id + ", Name: " + name + ", Email: " + email);
                   }
                   conn.close();
               } catch (SQLException e) {
                   e.printStackTrace();
               }
           }
       }
       ```

   - **Update (Atualização de Dados)**:
     - **Definição**: Atualizar registros existentes no banco de dados.
     - **Exemplo**:
       ```java
       import java.sql.Connection;
       import java.sql.DriverManager;
       import java.sql.PreparedStatement;
       import java.sql.SQLException;

       public class UpdateDemo {
           public static void main(String[] args) {
               String url = "jdbc:mysql://localhost:3306/mydatabase";
               String user = "root";
               String password = "password";

               try {
                   Connection conn = DriverManager.getConnection(url, user, password);
                   String sql = "UPDATE Customers SET email=? WHERE id=?";
                   PreparedStatement statement = conn.prepareStatement(sql);
                   statement.setString(1, "new.email@example.com");
                   statement.setInt(2, 1);
                   int rowsUpdated = statement.executeUpdate();
                   if (rowsUpdated > 0) {
                       System.out.println("An existing user was updated successfully!");
                   }
                   conn.close();
               } catch (SQLException e) {
                   e.printStackTrace();
               }
           }
       }
       ```

   - **Delete (Exclusão de Dados)**:
     - **Definição**: Remover registros do banco de dados.
     - **Exemplo**:
       ```java
       import java.sql.Connection;
       import java.sql.DriverManager;
       import java.sql.PreparedStatement;
       import java.sql.SQLException;

       public class DeleteDemo {
           public static void main(String[] args) {
               String url = "jdbc:mysql://localhost:3306/mydatabase";
               String user = "root";
               String password = "password";

               try {
                   Connection conn = DriverManager.getConnection(url, user, password);
                   String sql = "DELETE FROM Customers WHERE id=?";
                   PreparedStatement statement = conn.prepareStatement(sql);
                   statement.setInt(1, 1);
                   int rowsDeleted = statement.executeUpdate();
                   if (rowsDeleted > 0) {
                       System.out.println("A user was deleted successfully!");
                   }
                   conn.close();
               } catch (SQLException e) {
                   e.printStackTrace();
               }
           }
       }
       ```

#### Exemplo Completo

**Objetivo**: Demonstrar conceitos de conexão JDBC e operações CRUD.

```java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class JDBCDemo {
    private static final String URL = "jdbc:mysql://localhost:3306/mydatabase";
    private static final String USER = "root";
    private static final String PASSWORD = "password";

    public static void main(String[] args) {
        try {
            Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);
            System.out.println("Connection established successfully!");

            // Create
            String insertSql = "INSERT INTO Customers (name, email) VALUES (?, ?)";
            PreparedStatement insertStatement = conn.prepareStatement(insertSql);
            insertStatement.setString(1, "John Doe");
            insertStatement.setString(2, "john.doe@example.com");
            int rowsInserted = insertStatement.executeUpdate();
            if (rowsInserted > 0) {
                System.out.println("A new user was inserted successfully!");
            }

            // Read
            String selectSql = "SELECT * FROM Customers";
            Statement selectStatement = conn.createStatement();
            ResultSet resultSet = selectStatement.executeQuery(selectSql);
            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String name = resultSet.getString("name");
                String email = resultSet.getString("email");
                System.out.println("ID: " + id + ", Name: " + name + ", Email: " + email);
            }

            // Update
            String updateSql = "UPDATE Customers SET email=? WHERE id=?";
            PreparedStatement updateStatement = conn.prepareStatement(updateSql);
            updateStatement.setString(1, "new.email@example.com");
            updateStatement.setInt(2, 1);
            int rowsUpdated = updateStatement.executeUpdate();
            if (rowsUpdated > 0) {
                System.out.println("An existing user was updated successfully!");
            }

            // Delete
            String deleteSql = "DELETE FROM Customers WHERE id=?";
            PreparedStatement deleteStatement = conn.prepareStatement(deleteSql);
            deleteStatement.setInt(1, 1);
            int rowsDeleted = deleteStatement.executeUpdate();
            if (rowsDeleted > 0) {
                System.out.println("A user was deleted successfully!");
            }

            conn.close();
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
}
```

**Exercícios**:
1. **Inserção de Dados**: Criar um programa que insere múltiplos registros em uma tabela de produtos com informações como nome, preço e quantidade.
2. **Consulta de Dados**: Desenvolver um programa que consulta e exibe registros de uma tabela de funcionários, ordenados por salário.
3. **Atualização de Dados**: Implementar um programa que atualiza o preço de um produto em uma tabela baseada em seu ID.
4. **Exclusão de Dados**: Criar um programa que exclui registros de uma tabela de pedidos que foram feitos há mais de um ano.
5. **Transações JDBC**: Desenvolver um programa que realiza operações de débito e crédito em uma conta bancária, garantindo a consistência dos dados utilizando transações.


## 3. Concurrency

**Conceitos**:
- **Threads**: A unidade básica de execução. Em Java, uma aplicação pode ter várias threads para realizar tarefas simultaneamente.
- **Sincronização**: Garantir que múltiplas threads possam acessar recursos compartilhados sem interferir umas nas outras.
- **Pacote `java.util.concurrent`**: Fornece classes utilitárias para trabalhar com concorrência de maneira eficiente, como `ExecutorService`, `CountDownLatch`, `Semaphore`, e `ConcurrentHashMap`.

#### Explicação Detalhada

1. **Threads**:
   - **Definição**: Uma thread é a menor unidade de processamento que pode ser executada de forma independente. Em Java, cada thread tem seu próprio caminho de execução.
   - **Criação de Threads**:
     - **Extender a classe `Thread`**: Uma maneira de criar uma thread é estendendo a classe `Thread` e sobrescrevendo o método `run()`.
     - **Implementar a interface `Runnable`**: Outra maneira é implementando a interface `Runnable` e passando uma instância de `Runnable` para um objeto `Thread`.
   - **Exemplo de Criação de Threads**:
     ```java
     // Estendendo a classe Thread
     class MyThread extends Thread {
         public void run() {
             System.out.println("Thread is running");
         }
     }

     // Implementando a interface Runnable
     class MyRunnable implements Runnable {
         public void run() {
             System.out.println("Runnable is running");
         }
     }

     public class ThreadExample {
         public static void main(String[] args) {
             MyThread t1 = new MyThread();
             t1.start();

             Thread t2 = new Thread(new MyRunnable());
             t2.start();
         }
     }
     ```

2. **Sincronização**:
   - **Definição**: Sincronização é o mecanismo que garante que múltiplas threads não interfiram umas nas outras ao acessar recursos compartilhados.
   - **Synchronized Blocks e Methods**: Usar a palavra-chave `synchronized` para proteger blocos de código ou métodos inteiros que devem ser acessados por uma thread por vez.
   - **Exemplo de Sincronização**:
     ```java
     class Counter {
         private int count = 0;

         public synchronized void increment() {
             count++;
         }

         public int getCount() {
             return count;
         }
     }

     public class SyncExample {
         public static void main(String[] args) throws InterruptedException {
             Counter counter = new Counter();

             Runnable task = () -> {
                 for (int i = 0; i < 1000; i++) {
                     counter.increment();
                 }
             };

             Thread t1 = new Thread(task);
             Thread t2 = new Thread(task);

             t1.start();
             t2.start();

             t1.join();
             t2.join();

             System.out.println("Count: " + counter.getCount());
         }
     }
     ```

3. **Pacote `java.util.concurrent`**:
   - **ExecutorService**: Uma interface que representa um pool de threads. Permite executar tarefas de forma assíncrona.
   - **CountDownLatch**: Um sincronizador que permite que uma ou mais threads esperem até que um conjunto de operações em outras threads seja concluído.
   - **Semaphore**: Um contador que controla o acesso a um recurso compartilhado.
   - **ConcurrentHashMap**: Uma implementação de `HashMap` segura para o uso concorrente.
   - **Exemplo de `ExecutorService`**:
     ```java
     import java.util.concurrent.ExecutorService;
     import java.util.concurrent.Executors;

     public class ExecutorServiceExample {
         public static void main(String[] args) {
             ExecutorService executor = Executors.newFixedThreadPool(3);

             for (int i = 0; i < 10; i++) {
                 executor.execute(new WorkerThread("" + i));
             }
             executor.shutdown();
             while (!executor.isTerminated()) {
             }

             System.out.println("Finished all threads");
         }
     }

     class WorkerThread implements Runnable {
         private String command;

         public WorkerThread(String s) {
             this.command = s;
         }

         @Override
         public void run() {
             System.out.println(Thread.currentThread().getName() + " Start. Command = " + command);
             processCommand();
             System.out.println(Thread.currentThread().getName() + " End.");
         }

         private void processCommand() {
             try {
                 Thread.sleep(5000);
             } catch (InterruptedException e) {
                 e.printStackTrace();
             }
         }

         @Override
         public String toString() {
             return this.command;
         }
     }
     ```

#### Exemplo Completo

**Objetivo**: Demonstrar conceitos de criação e sincronização de threads e uso do pacote `java.util.concurrent`.

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ConcurrencyExample {
    public static void main(String[] args) {
        // Criação de Threads
        MyThread t1 = new MyThread();
        t1.start();

        Thread t2 = new Thread(new MyRunnable());
        t2.start();

        // Sincronização
        Counter counter = new Counter();
        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.increment();
            }
        };

        Thread t3 = new Thread(task);
        Thread t4 = new Thread(task);

        t3.start();
        t4.start();

        try {
            t3.join();
            t4.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Count: " + counter.getCount());

        // ExecutorService
        ExecutorService executor = Executors.newFixedThreadPool(3);
        for (int i = 0; i < 10; i++) {
            executor.execute(new WorkerThread("" + i));
        }
        executor.shutdown();
        while (!executor.isTerminated()) {
        }

        System.out.println("Finished all threads");
    }
}

class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running");
    }
}

class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Runnable is running");
    }
}

class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public int getCount() {
        return count;
    }
}

class WorkerThread implements Runnable {
    private String command;

    public WorkerThread(String s) {
        this.command = s;
    }

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + " Start. Command = " + command);
        processCommand();
        System.out.println(Thread.currentThread().getName() + " End.");
    }

    private void processCommand() {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public String toString() {
        return this.command;
    }
}
```

**Exercícios**:
1. **Criação de Threads**: Criar um programa que cria e inicia várias threads que executam tarefas diferentes, exibindo mensagens distintas.
2. **Sincronização**: Desenvolver um programa que utiliza a sincronização para garantir que múltiplas threads incrementem um contador de forma correta.
3. **ExecutorService**: Implementar um programa que usa `ExecutorService` para gerenciar um pool de threads que realizam tarefas de cálculo em paralelo.
4. **CountDownLatch**: Criar um programa que utiliza `CountDownLatch` para fazer com que uma thread espere até que várias outras threads completem suas tarefas.
5. **ConcurrentHashMap**: Desenvolver um programa que utiliza `ConcurrentHashMap` para contar a frequência de palavras em um texto, processando várias partes do texto em paralelo.



## 4. Exceptions and Assertions

**Conceitos**:
- **Exceções**: São eventos anômalos que podem ocorrer durante a execução de um programa, interrompendo seu fluxo normal. Java possui uma hierarquia de exceções que permite capturar e tratar esses eventos.
- **Assertions**: Ferramentas para teste e verificação de condições durante o desenvolvimento. Assertions são utilizadas para verificar invariantes no código e ajudam a identificar bugs mais cedo no ciclo de desenvolvimento.

#### Explicação Detalhada

1. **Exceções**:
   - **Definição**: Exceções são problemas que ocorrem durante a execução de um programa, como erros de leitura de arquivos, divisão por zero, ou acesso a um índice inválido em um array.
   - **Tipos de Exceções**:
     - **Checked Exceptions**: Exceções verificadas em tempo de compilação. Devem ser capturadas ou declaradas no método com `throws`. Exemplos: `IOException`, `SQLException`.
     - **Unchecked Exceptions**: Exceções não verificadas em tempo de compilação. São subclasses de `RuntimeException`. Exemplos: `NullPointerException`, `ArrayIndexOutOfBoundsException`.
     - **Errores**: Problemas graves que normalmente não podem ser recuperados pelo programa. São subclasses de `Error`. Exemplos: `OutOfMemoryError`, `StackOverflowError`.
   - **Tratamento de Exceções**:
     - **try-catch**: Bloco que tenta executar o código e captura exceções.
     - **finally**: Bloco que sempre é executado, independentemente de uma exceção ter sido lançada ou não.
     - **throws**: Declara que um método pode lançar uma exceção.
   - **Exemplo de Tratamento de Exceções**:
     ```java
     public class ExceptionExample {
         public static void main(String[] args) {
             try {
                 int result = divide(10, 0);
                 System.out.println("Result: " + result);
             } catch (ArithmeticException e) {
                 System.out.println("Error: " + e.getMessage());
             } finally {
                 System.out.println("Execution completed.");
             }
         }

         public static int divide(int a, int b) {
             return a / b;
         }
     }
     ```

2. **Criando Exceções Personalizadas**:
   - **Definição**: Além das exceções fornecidas pela linguagem, podemos criar nossas próprias exceções para representar condições de erro específicas em nosso domínio de aplicação.
   - **Exemplo de Exceção Personalizada**:
     ```java
     public class InvalidAgeException extends Exception {
         public InvalidAgeException(String message) {
             super(message);
         }
     }

     public class TestCustomException {
         public static void main(String[] args) {
             try {
                 checkAge(15);
             } catch (InvalidAgeException e) {
                 System.out.println("Caught exception: " + e.getMessage());
             }
         }

         public static void checkAge(int age) throws InvalidAgeException {
             if (age < 18) {
                 throw new InvalidAgeException("Age must be 18 or older.");
             }
         }
     }
     ```

3. **Assertions**:
   - **Definição**: Assertions são utilizadas para verificar condições que o programador acredita que devem ser sempre verdadeiras. Se uma assertiva falhar, uma `AssertionError` é lançada.
   - **Quando Usar**: Assertions são usadas durante o desenvolvimento e testes, não em código de produção. São úteis para verificar invariantes, pré-condições e pós-condições.
   - **Habilitando e Desabilitando Assertions**: Por padrão, assertions estão desabilitadas. Para habilitá-las, deve-se usar a opção `-ea` (enable assertions) na linha de comando.
   - **Exemplo de Uso de Assertions**:
     ```java
     public class AssertionExample {
         public static void main(String[] args) {
             int value = -10;
             assert value >= 0 : "Value must be non-negative: " + value;
             System.out.println("Value is " + value);
         }
     }
     ```

#### Exemplo Completo

**Objetivo**: Demonstrar conceitos de tratamento de exceções e uso de assertions.

```java
public class CompleteExample {
    public static void main(String[] args) {
        try {
            int result = divide(10, 0);
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            System.out.println("Error: " + e.getMessage());
        } finally {
            System.out.println("Execution completed.");
        }

        try {
            checkAge(15);
        } catch (InvalidAgeException e) {
            System.out.println("Caught exception: " + e.getMessage());
        }

        int value = -10;
        assert value >= 0 : "Value must be non-negative: " + value;
        System.out.println("Value is " + value);
    }

    public static int divide(int a, int b) {
        return a / b;
    }

    public static void checkAge(int age) throws InvalidAgeException {
        if (age < 18) {
            throw new InvalidAgeException("Age must be 18 or older.");
        }
    }
}

class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}
```

**Exercícios**:
1. **Exceções**: Criar um programa que lê números de um arquivo e calcula a média. Trate exceções como `FileNotFoundException` e `NumberFormatException`.
2. **Exceções Personalizadas**: Desenvolver uma exceção personalizada `NegativeNumberException` que é lançada quando um número negativo é encontrado em uma lista de números.
3. **Assertions**: Implementar um programa que utiliza assertions para verificar pré-condições e pós-condições de métodos de manipulação de listas.
4. **Hierarquia de Exceções**: Criar uma hierarquia de exceções para um sistema bancário, com exceções para saldo insuficiente, conta não encontrada, e transações inválidas.
5. **Tratamento Completo de Exceções**: Desenvolver um programa que realiza operações matemáticas complexas e utiliza blocos `try-catch-finally` para garantir a limpeza dos recursos utilizados.

## 5. Generics and Collections

**Conceitos**:
- **Genéricos**: Permitem criar classes, interfaces e métodos parametrizados por tipos. Eles ajudam a garantir a segurança de tipo em tempo de compilação e reduzem a necessidade de castings explícitos.
- **Coleções**: Estruturas de dados que armazenam grupos de objetos. As principais interfaces de coleções em Java são `List`, `Set` e `Map`.

#### Explicação Detalhada

1. **Genéricos**:
   - **Definição**: Genéricos permitem que classes, interfaces e métodos operem em tipos parametrizados.
   - **Vantagens**: Segurança de tipo, reutilização de código, eliminação de castings explícitos.
   - **Exemplo de Classe Genérica**:
     ```java
     public class Box<T> {
         private T value;

         public void set(T value) {
             this.value = value;
         }

         public T get() {
             return value;
         }
     }

     public class TestBox {
         public static void main(String[] args) {
             Box<Integer> intBox = new Box<>();
             intBox.set(123);
             System.out.println("Integer Value: " + intBox.get());

             Box<String> strBox = new Box<>();
             strBox.set("Hello");
             System.out.println("String Value: " + strBox.get());
         }
     }
     ```

2. **List**:
   - **Definição**: `List` é uma coleção ordenada que permite elementos duplicados.
   - **Principais Implementações**: `ArrayList`, `LinkedList`.
   - **Exemplo de Uso de `ArrayList`**:
     ```java
     import java.util.ArrayList;
     import java.util.List;

     public class ListExample {
         public static void main(String[] args) {
             List<String> list = new ArrayList<>();
             list.add("Apple");
             list.add("Banana");
             list.add("Cherry");

             System.out.println("List: " + list);
             System.out.println("First element: " + list.get(0));
             list.remove(1);
             System.out.println("Updated List: " + list);
         }
     }
     ```

3. **Set**:
   - **Definição**: `Set` é uma coleção que não permite elementos duplicados.
   - **Principais Implementações**: `HashSet`, `LinkedHashSet`, `TreeSet`.
   - **Exemplo de Uso de `HashSet`**:
     ```java
     import java.util.HashSet;
     import java.util.Set;

     public class SetExample {
         public static void main(String[] args) {
             Set<String> set = new HashSet<>();
             set.add("Apple");
             set.add("Banana");
             set.add("Cherry");
             set.add("Apple"); // Duplicado, não será adicionado

             System.out.println("Set: " + set);
         }
     }
     ```

4. **Map**:
   - **Definição**: `Map` é uma coleção de pares chave-valor, onde cada chave é única.
   - **Principais Implementações**: `HashMap`, `LinkedHashMap`, `TreeMap`.
   - **Exemplo de Uso de `HashMap`**:
     ```java
     import java.util.HashMap;
     import java.util.Map;

     public class MapExample {
         public static void main(String[] args) {
             Map<String, Integer> map = new HashMap<>();
             map.put("Apple", 1);
             map.put("Banana", 2);
             map.put("Cherry", 3);

             System.out.println("Map: " + map);
             System.out.println("Value for 'Apple': " + map.get("Apple"));
             map.remove("Banana");
             System.out.println("Updated Map: " + map);
         }
     }
     ```

5. **Coleções Genéricas**:
   - Combinação de genéricos com coleções permite garantir a segurança de tipo ao armazenar e recuperar elementos.
   - **Exemplo de Lista Genérica**:
     ```java
     import java.util.ArrayList;
     import java.util.List;

     public class GenericListExample {
         public static void main(String[] args) {
             List<String> list = new ArrayList<>();
             list.add("Apple");
             list.add("Banana");
             list.add("Cherry");

             for (String fruit : list) {
                 System.out.println(fruit);
             }
         }
     }
     ```

#### Exemplo Completo

**Objetivo**: Demonstrar o uso de genéricos e coleções em Java.

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class GenericsCollectionsExample {
    public static void main(String[] args) {
        // Uso de List
        List<String> list = new ArrayList<>();
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");
        System.out.println("List: " + list);

        // Uso de Set
        Set<String> set = new HashSet<>();
        set.add("Apple");
        set.add("Banana");
        set.add("Cherry");
        set.add("Apple"); // Duplicado, não será adicionado
        System.out.println("Set: " + set);

        // Uso de Map
        Map<String, Integer> map = new HashMap<>();
        map.put("Apple", 1);
        map.put("Banana", 2);
        map.put("Cherry", 3);
        System.out.println("Map: " + map);

        // Uso de classe genérica
        Box<Integer> intBox = new Box<>();
        intBox.set(123);
        System.out.println("Integer Value: " + intBox.get());

        Box<String> strBox = new Box<>();
        strBox.set("Hello");
        System.out.println("String Value: " + strBox.get());
    }
}

class Box<T> {
    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}
```

**Exercícios**:
1. **Genéricos**: Criar uma classe genérica `Pair` que armazena dois valores de tipos possivelmente diferentes. Implementar métodos para acessar esses valores.
2. **Lista Genérica**: Implementar uma lista genérica que armazena instâncias de uma classe `Produto` e fornece métodos para adicionar, remover e listar produtos.
3. **Uso de Set**: Criar um programa que lê uma lista de nomes de um arquivo e armazena apenas os nomes únicos usando um `HashSet`.
4. **Map Genérico**: Desenvolver um programa que utiliza um `HashMap` para mapear nomes de países para suas capitais e permite a busca interativa dessas informações.
5. **Manipulação de Coleções**: Criar uma classe que utiliza métodos da interface `Collection` para manipular elementos em uma coleção genérica (adicionar, remover, verificar existência).


## 6. Java Class Design

**Conceitos**:
- **Design de Classes**: Envolve princípios de design orientado a objetos, como coesão, acoplamento, responsabilidade única, encapsulamento, herança e polimorfismo. Um bom design de classes melhora a manutenibilidade, a reutilização e a compreensão do código.
- **Métodos Avançados**: Incluem métodos estáticos, métodos de instância, construtores, sobrecarga de métodos e uso de modificadores de acesso (public, private, protected).
- **Encapsulamento**: Prática de esconder os detalhes de implementação de uma classe e expor apenas a interface pública. Utiliza modificadores de acesso para proteger os dados.
- **Herança**: Mecanismo que permite que uma classe herde atributos e métodos de outra classe.
- **Polimorfismo**: Capacidade de uma variável, objeto ou função tomar várias formas. Utilizado para métodos sobrecarregados e sobrepostos.

#### Explicação Detalhada

1. **Encapsulamento**:
   - **Definição**: Técnica de esconder os detalhes de implementação de uma classe, protegendo os dados e expondo apenas os métodos necessários.
   - **Uso de Modificadores de Acesso**: `private`, `protected`, `public`.
   - **Métodos Getter e Setter**:
     ```java
     public class Person {
         private String name;
         private int age;

         public String getName() {
             return name;
         }

         public void setName(String name) {
             this.name = name;
         }

         public int getAge() {
             return age;
         }

         public void setAge(int age) {
             this.age = age;
         }
     }
     ```

2. **Herança**:
   - **Definição**: Permite que uma classe (`subclasse`) herde atributos e métodos de outra classe (`superclasse`).
   - **Uso do Extends**:
     ```java
     public class Animal {
         public void eat() {
             System.out.println("This animal eats food.");
         }
     }

     public class Dog extends Animal {
         public void bark() {
             System.out.println("The dog barks.");
         }
     }

     public class TestAnimal {
         public static void main(String[] args) {
             Dog dog = new Dog();
             dog.eat(); // Herança do método eat da classe Animal
             dog.bark();
         }
     }
     ```

3. **Polimorfismo**:
   - **Definição**: Habilidade de tratar objetos de diferentes classes de maneira uniforme.
   - **Polimorfismo de Sobrecarga**: Definir múltiplos métodos com o mesmo nome, mas diferentes parâmetros.
   - **Polimorfismo de Sobrescrita**: Substituir a implementação de um método na subclasse.
   - **Exemplo de Sobrecarga**:
     ```java
     public class MathUtils {
         public int add(int a, int b) {
             return a + b;
         }

         public double add(double a, double b) {
             return a + b;
         }
     }
     ```
   - **Exemplo de Sobrescrita**:
     ```java
     public class Animal {
         public void makeSound() {
             System.out.println("Animal makes a sound");
         }
     }

     public class Dog extends Animal {
         @Override
         public void makeSound() {
             System.out.println("Dog barks");
         }
     }

     public class TestAnimal {
         public static void main(String[] args) {
             Animal myDog = new Dog();
             myDog.makeSound(); // Chama o método sobrescrito na classe Dog
         }
     }
     ```

4. **Métodos Estáticos e de Instância**:
   - **Métodos Estáticos**: Pertencem à classe e podem ser chamados sem criar uma instância da classe.
   - **Métodos de Instância**: Pertencem a uma instância específica da classe e podem acessar os campos de instância da classe.
   - **Exemplo de Método Estático**:
     ```java
     public class Utility {
         public static void printMessage() {
             System.out.println("This is a static method");
         }
     }

     public class TestUtility {
         public static void main(String[] args) {
             Utility.printMessage(); // Chama o método estático sem criar uma instância
         }
     }
     ```

5. **Sobrecarga de Construtores**:
   - **Definição**: Permitir a criação de múltiplos construtores na mesma classe, cada um com diferentes parâmetros.
   - **Exemplo**:
     ```java
     public class Person {
         private String name;
         private int age;

         // Construtor sem parâmetros
         public Person() {
             this.name = "Unknown";
             this.age = 0;
         }

         // Construtor com um parâmetro
         public Person(String name) {
             this.name = name;
             this.age = 0;
         }

         // Construtor com dois parâmetros
         public Person(String name, int age) {
             this.name = name;
             this.age = age;
         }
     }

     public class TestPerson {
         public static void main(String[] args) {
             Person person1 = new Person();
             Person person2 = new Person("Alice");
             Person person3 = new Person("Bob", 30);

             System.out.println(person1.getName() + ", " + person1.getAge());
             System.out.println(person2.getName() + ", " + person2.getAge());
             System.out.println(person3.getName() + ", " + person3.getAge());
         }
     }
     ```

#### Exemplo Completo

**Objetivo**: Demonstrar conceitos de encapsulamento, herança, polimorfismo, métodos estáticos e de instância, e sobrecarga de construtores.

```java
public class DesignExample {
    private String name;
    private int age;

    // Construtor sobrecarregado
    public DesignExample() {
        this.name = "Unknown";
        this.age = 0;
    }

    public DesignExample(String name) {
        this.name = name;
        this.age = 0;
    }

    public DesignExample(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Métodos getter e setter
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    // Método estático
    public static void printClassName() {
        System.out.println("DesignExample");
    }

    // Método de instância
    public void printDetails() {
        System.out.println("Name: " + name + ", Age: " + age);
    }

    public static void main(String[] args) {
        DesignExample person1 = new DesignExample();
        DesignExample person2 = new DesignExample("Alice");
        DesignExample person3 = new DesignExample("Bob", 30);

        // Chamando método estático
        DesignExample.printClassName();

        // Chamando métodos de instância
        person1.printDetails();
        person2.printDetails();
        person3.printDetails();
    }
}
```

**Exercícios**:
1. **Encapsulamento**: Criar uma classe `Car` com atributos privados `marca`, `modelo` e `ano`, e métodos públicos `get` e `set` para acessar esses atributos.
2. **Herança**: Desenvolver uma hierarquia de classes onde `Vehicle` é a superclasse, e `Car` e `Motorcycle` são subclasses que herdam de `Vehicle`.
3. **Polimorfismo**: Implementar um método que aceita um parâmetro do tipo `Vehicle` e demonstra o uso de polimorfismo.
4. **Métodos Estáticos e de Instância**: Criar uma classe `Calculator` com métodos estáticos para operações matemáticas básicas e métodos de instância para armazenar e manipular um resultado calculado.
5. **Sobrecarga de Construtores**: Criar uma classe `Book` com construtores sobrecarregados para inicializar o objeto com diferentes conjuntos de parâmetros.

Ao compreender e aplicar esses conceitos de design de classes, os desenvolvedores podem criar códigos que são bem estruturados, fáceis de manter e altamente reutilizáveis, aproveitando ao máximo os princípios da programação orientada a objetos.

## 7. Java File I/O (NIO.2)

**Conceitos**:
- **NIO.2**: A API de entrada/saída introduzida no Java 7, conhecida como NIO.2, fornece uma maneira mais eficiente e flexível de realizar operações de I/O em arquivos e sistemas de arquivos. É uma melhoria significativa em relação à API de I/O original do Java (NIO) introduzida no Java 1.4.
- **Principais Classes**:
  - **Path**: Representa um caminho de arquivo ou diretório e é a base para muitas operações de I/O.
  - **Files**: Utilitária para operações comuns com arquivos, como leitura, escrita, cópia, e exclusão.
  - **FileSystem**: Fornece uma visão do sistema de arquivos e suas propriedades.
  - **FileAttribute**: Usada para configurar atributos de arquivos durante a criação de arquivos ou diretórios.
  - **DirectoryStream**: Iterador para percorrer o conteúdo de um diretório.
  - **FileVisitor**: Interface que permite visitar arquivos e diretórios recursivamente.

#### Explicação Detalhada

1. **Path**:
   - A classe `Path` representa uma localização de arquivo ou diretório em um sistema de arquivos. Pode ser usado para construir caminhos de arquivos e realizar operações baseadas nesses caminhos.
   - **Criação de Path**:
     ```java
     Path path = Paths.get("example.txt");
     Path dir = Paths.get("mydirectory");
     ```
   - **Métodos Comuns**:
     - `getFileName()`: Obtém o nome do arquivo ou diretório.
     - `getParent()`: Obtém o caminho pai.
     - `toAbsolutePath()`: Obtém o caminho absoluto.
     - `resolve()`: Resolve um caminho contra outro caminho.

2. **Files**:
   - A classe `Files` fornece métodos estáticos para operações comuns com arquivos, como leitura, escrita, cópia, exclusão e criação de diretórios.
   - **Leitura e Escrita**:
     ```java
     Path path = Paths.get("example.txt");
     Files.write(path, "Hello, NIO.2!".getBytes());
     String content = new String(Files.readAllBytes(path));
     ```
   - **Cópia e Movimentação**:
     ```java
     Path sourcePath = Paths.get("example.txt");
     Path targetPath = Paths.get("example_copy.txt");
     Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
     Files.move(targetPath, Paths.get("example_moved.txt"), StandardCopyOption.REPLACE_EXISTING);
     ```
   - **Criação de Diretórios**:
     ```java
     Path dirPath = Paths.get("newdir");
     if (!Files.exists(dirPath)) {
         Files.createDirectory(dirPath);
     }
     ```

3. **FileSystem**:
   - A classe `FileSystem` fornece informações sobre o sistema de arquivos, como as raízes do sistema de arquivos e o separador de caminho usado pelo sistema operacional.
   - **Obtenção do Sistema de Arquivos**:
     ```java
     FileSystem fs = FileSystems.getDefault();
     for (Path root : fs.getRootDirectories()) {
         System.out.println(root);
     }
     ```

4. **FileAttribute**:
   - Usada para definir atributos de arquivos e diretórios no momento da criação. Por exemplo, você pode definir permissões de arquivo ou outras propriedades específicas do sistema de arquivos.
   - **Exemplo de Uso**:
     ```java
     Path path = Paths.get("example.txt");
     Set<PosixFilePermission> perms = PosixFilePermissions.fromString("rw-r--r--");
     FileAttribute<Set<PosixFilePermission>> attr = PosixFilePermissions.asFileAttribute(perms);
     Files.createFile(path, attr);
     ```

5. **DirectoryStream**:
   - A interface `DirectoryStream` fornece um iterador para percorrer o conteúdo de um diretório. É útil para listar arquivos e diretórios de maneira eficiente.
   - **Exemplo de Uso**:
     ```java
     try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get("."))) {
         for (Path entry : stream) {
             System.out.println(entry.getFileName());
         }
     } catch (IOException e) {
         e.printStackTrace();
     }
     ```

6. **FileVisitor**:
   - A interface `FileVisitor` permite visitar arquivos e diretórios recursivamente. É útil para operações que envolvem percorrer uma estrutura de diretórios.
   - **Exemplo de Uso**:
     ```java
     Path startPath = Paths.get("startDir");
     Files.walkFileTree(startPath, new SimpleFileVisitor<Path>() {
         @Override
         public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
             System.out.println("Visited file: " + file);
             return FileVisitResult.CONTINUE;
         }

         @Override
         public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
             System.err.println("Failed to visit file: " + file);
             return FileVisitResult.CONTINUE;
         }

         @Override
         public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
             System.out.println("Visited directory: " + dir);
             return FileVisitResult.CONTINUE;
         }
     });
     ```

7. **Manipulação de Arquivos com NIO.2**:
   - A API NIO.2 facilita operações de I/O de maneira não bloqueante e assíncrona, melhorando o desempenho em aplicativos que lidam com grandes volumes de dados ou I/O intensivo.
   - **Operações Assíncronas**:
     ```java
     Path path = Paths.get("example.txt");
     AsynchronousFileChannel channel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);
     ByteBuffer buffer = ByteBuffer.allocate(1024);
     Future<Integer> result = channel.read(buffer, 0);

     while (!result.isDone()) {
         System.out.println("Doing something else while reading...");
     }

     int bytesRead = result.get();
     System.out.println("Bytes read: " + bytesRead);
     ```

**Exercícios**:
1. **Ler e Escrever Arquivos**: Criar um programa que lê um arquivo de texto linha por linha e imprime o conteúdo no console.
2. **Copiar e Mover Arquivos**: Desenvolver um programa que copia arquivos de um diretório para outro e depois move esses arquivos para um terceiro diretório.
3. **Listar Arquivos em um Diretório**: Escrever um programa que lista todos os arquivos e diretórios em um diretório específico.
4. **Recorrer Diretórios**: Implementar uma classe que utiliza `FileVisitor` para percorrer todos os arquivos em um diretório e subdiretórios e imprime seus nomes e tamanhos.
5. **Manipulação de Atributos de Arquivos**: Criar um programa que cria um arquivo com permissões específicas e depois altera essas permissões.


## 8. Java Stream API

**Conceitos**:
- **Streams**: Uma sequência de elementos que suporta operações agregadas de forma sequencial ou paralela. Streams permitem processar coleções de objetos de maneira declarativa, expressando o que deve ser feito ao invés de como fazer.
- **Pipeline de Operações**: Streams são compostos por uma pipeline de operações, que inclui:
  - **Operações de Criação**: Criação de streams a partir de fontes como coleções, arrays ou funções.
  - **Operações Intermediárias**: Operações que transformam um stream em outro stream, como `filter()`, `map()`, `sorted()`, etc.
  - **Operações Terminais**: Operações que produzem um resultado ou efeito colateral, como `forEach()`, `collect()`, `reduce()`, etc.
- **Lambda Expressions**: Funções anônimas que são frequentemente utilizadas para definir o comportamento de operações em streams.

#### Explicação Detalhada

1. **Criação de Streams**:
   - Streams podem ser criados a partir de coleções, arrays ou funções. O método `stream()` em uma coleção retorna um stream sequencial, enquanto o método `parallelStream()` retorna um stream paralelo.
   - **Exemplo de criação de um stream a partir de uma lista**:
     ```java
     List<String> list = Arrays.asList("a", "b", "c");
     Stream<String> stream = list.stream();
     ```

2. **Operações Intermediárias**:
   - **`filter(Predicate)`**: Retorna um stream contendo apenas os elementos que correspondem ao predicado fornecido.
   - **`map(Function)`**: Retorna um stream cujos elementos são os resultados da aplicação da função fornecida a cada elemento do stream original.
   - **`sorted(Comparator)`**: Retorna um stream cujos elementos são ordenados de acordo com o comparador fornecido.
   - **`distinct()`**: Retorna um stream que contém elementos distintos (sem duplicatas).
   - **Exemplo de uso de `filter()` e `map()`**:
     ```java
     List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
     List<String> result = words.stream()
                                .filter(word -> word.startsWith("a"))
                                .map(String::toUpperCase)
                                .collect(Collectors.toList());
     System.out.println(result); // Output: [APPLE]
     ```

3. **Operações Terminais**:
   - **`forEach(Consumer)`**: Aplica uma ação a cada elemento do stream.
   - **`collect(Collector)`**: Converte o stream em outra forma, como uma lista ou conjunto.
   - **`reduce(BinaryOperator)`**: Combina os elementos do stream usando uma operação associativa e retorna um resultado.
   - **Exemplo de uso de `forEach()`**:
     ```java
     List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
     words.stream().forEach(System.out::println);
     ```

4. **Lambda Expressions**:
   - Lambda expressions fornecem uma maneira concisa de representar funções anônimas. Elas são usadas extensivamente com a API de Streams para passar comportamento para métodos.
   - **Exemplo de lambda expression**:
     ```java
     (String s) -> s.length()
     ```

5. **Pipeline de Operações**:
   - Um pipeline de stream é composto por uma fonte (coleção, array, etc.), zero ou mais operações intermediárias, e uma operação terminal.
   - **Exemplo de pipeline**:
     ```java
     List<String> result = list.stream()
                               .filter(s -> s.startsWith("a"))
                               .map(String::toUpperCase)
                               .sorted()
                               .collect(Collectors.toList());
     ```

#### Exemplo Completo
**Objetivo**: Demonstrar um exemplo de pipeline de operações usando a API de Streams do Java.

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class StreamExample {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("Hello", "World", "Java", "Streams");

        // Filtrar palavras que começam com "J" e imprimir
        List<String> result = words.stream()
                                   .filter(word -> word.startsWith("J"))
                                   .map(String::toUpperCase)
                                   .sorted()
                                   .collect(Collectors.toList());

        result.forEach(System.out::println);
    }
}
```

**Exercícios**:
1. **Filtrar e Mapear**: Criar um programa que filtra uma lista de números para incluir apenas números pares e depois os multiplica por 2.
2. **Redução**: Desenvolver um programa que encontra a soma de uma lista de inteiros usando o método `reduce()`.
3. **Coleta**: Escrever um programa que converte uma lista de strings em um `Set` de strings em letras maiúsculas.
4. **Contagem de Palavras**: Implementar um programa que lê um texto e conta a frequência de cada palavra usando streams.
5. **Agrupamento**: Desenvolver um programa que agrupa uma lista de pessoas por idade usando `Collectors.groupingBy()`.

## 9. Localization

**Conceitos**:
- **Internacionalização (i18n)**: Processo de projetar software para que ele possa ser adaptado a vários idiomas e regiões sem a necessidade de engenharia adicional. Isso inclui a utilização de recursos como `Locale`, `ResourceBundle`, `NumberFormat`, e `DateFormat`.
- **Localização (l10n)**: Processo de adaptação do software para um idioma específico e requisitos regionais, como tradução de texto, formatação de datas, números e moedas.

#### Explicação Detalhada

1. **Utilização de `Locale`**:
   - A classe `Locale` representa uma localização geográfica ou cultural. Pode ser usada para personalizar a exibição de dados, como textos, números e datas, conforme o idioma e as convenções culturais do usuário.
   - **Criação de `Locale`**:
     ```java
     Locale usLocale = new Locale("en", "US");
     Locale franceLocale = new Locale("fr", "FR");
     ```

2. **Formatação de Números e Moedas com `NumberFormat`**:
   - A classe `NumberFormat` é usada para formatar números, moedas e porcentagens de acordo com as convenções regionais.
   - **Exemplo de Formatação de Moeda**:
     ```java
     Locale usLocale = new Locale("en", "US");
     NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance(usLocale);
     double amount = 12345.67;
     System.out.println("US: " + currencyFormatter.format(amount));

     Locale franceLocale = new Locale("fr", "FR");
     currencyFormatter = NumberFormat.getCurrencyInstance(franceLocale);
     System.out.println("France: " + currencyFormatter.format(amount));
     ```

3. **Formatação de Datas com `DateFormat`**:
   - A classe `DateFormat` fornece métodos para formatar e analisar datas de acordo com as convenções regionais.
   - **Exemplo de Formatação de Data**:
     ```java
     import java.text.DateFormat;
     import java.util.Date;
     import java.util.Locale;

     public class DateFormatExample {
         public static void main(String[] args) {
             Date now = new Date();

             DateFormat usDateFormat = DateFormat.getDateInstance(DateFormat.SHORT, Locale.US);
             System.out.println("US: " + usDateFormat.format(now));

             DateFormat franceDateFormat = DateFormat.getDateInstance(DateFormat.SHORT, Locale.FRANCE);
             System.out.println("France: " + franceDateFormat.format(now));
         }
     }
     ```

4. **Uso de `ResourceBundle` para Tradução**:
   - A classe `ResourceBundle` permite carregar conjuntos de strings de diferentes arquivos de propriedades, dependendo do `Locale` atual. Isso facilita a tradução de mensagens de interface do usuário sem modificar o código fonte.
   - **Exemplo de `ResourceBundle`**:
     ```java
     import java.util.Locale;
     import java.util.ResourceBundle;

     public class ResourceBundleExample {
         public static void main(String[] args) {
             Locale usLocale = new Locale("en", "US");
             Locale franceLocale = new Locale("fr", "FR");

             ResourceBundle usBundle = ResourceBundle.getBundle("MessagesBundle", usLocale);
             System.out.println("US: " + usBundle.getString("greeting"));

             ResourceBundle franceBundle = ResourceBundle.getBundle("MessagesBundle", franceLocale);
             System.out.println("France: " + franceBundle.getString("greeting"));
         }
     }
     ```
     - **Arquivo MessagesBundle_en_US.properties**:
       ```
       greeting=Hello
       ```
     - **Arquivo MessagesBundle_fr_FR.properties**:
       ```
       greeting=Bonjour
       ```

5. **Formatação de Datas e Números**:
   - A formatação de datas e números pode variar significativamente entre diferentes locais. Por exemplo, nos EUA, as datas são geralmente formatadas como MM/dd/yyyy, enquanto na França o formato é dd/MM/yyyy.
   - **Exemplo de Formatação de Número**:
     ```java
     import java.text.NumberFormat;
     import java.util.Locale;

     public class NumberFormatExample {
         public static void main(String[] args) {
             double number = 12345.67;

             NumberFormat usFormat = NumberFormat.getNumberInstance(Locale.US);
             System.out.println("US: " + usFormat.format(number));

             NumberFormat franceFormat = NumberFormat.getNumberInstance(Locale.FRANCE);
             System.out.println("France: " + franceFormat.format(number));
         }
     }
     ```

**Exemplo Completo**

**Objetivo**: Demonstrar a internacionalização de uma aplicação simples usando `Locale`, `ResourceBundle`, `NumberFormat`, e `DateFormat`.

```java
import java.text.NumberFormat;
import java.text.DateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.ResourceBundle;

public class LocalizationExample {
    public static void main(String[] args) {
        Locale usLocale = new Locale("en", "US");
        Locale franceLocale = new Locale("fr", "FR");

        // Formatação de Moeda
        NumberFormat usCurrencyFormat = NumberFormat.getCurrencyInstance(usLocale);
        NumberFormat franceCurrencyFormat = NumberFormat.getCurrencyInstance(franceLocale);
        double amount = 12345.67;
        System.out.println("US Currency: " + usCurrencyFormat.format(amount));
        System.out.println("France Currency: " + franceCurrencyFormat.format(amount));

        // Formatação de Data
        Date now = new Date();
        DateFormat usDateFormat = DateFormat.getDateInstance(DateFormat.SHORT, usLocale);
        DateFormat franceDateFormat = DateFormat.getDateInstance(DateFormat.SHORT, franceLocale);
        System.out.println("US Date: " + usDateFormat.format(now));
        System.out.println("France Date: " + franceDateFormat.format(now));

        // Mensagens Localizadas
        ResourceBundle usBundle = ResourceBundle.getBundle("MessagesBundle", usLocale);
        ResourceBundle franceBundle = ResourceBundle.getBundle("MessagesBundle", franceLocale);
        System.out.println("US Greeting: " + usBundle.getString("greeting"));
        System.out.println("France Greeting: " + franceBundle.getString("greeting"));
    }
}
```

**Exercícios**:
1. **Formatação de Números**: Criar um programa que formata números para diferentes moedas (por exemplo, dólar, euro e iene) utilizando `NumberFormat` e diferentes `Locale`.
2. **Tradução de Mensagens**: Implementar um sistema de mensagens multilíngue utilizando `ResourceBundle` para carregar diferentes arquivos de propriedades baseados no `Locale` atual.
3. **Formatação de Datas**: Desenvolver um programa que formata datas em diferentes formatos regionais utilizando `DateFormat` e `Locale`.
4. **Formatação de Percentuais**: Criar um programa que formata percentuais de acordo com diferentes locais utilizando `NumberFormat`.
5. **Detecção de Locale do Sistema**: Escrever um programa que detecta o `Locale` padrão do sistema e formata uma mensagem e um número de acordo com esse `Locale`.


## 10. Java SE 8 Date/Time API

**Conceitos**:
- A API de data/hora do Java SE 8, introduzida no pacote `java.time`, oferece uma forma moderna e intuitiva de manipulação de datas e horas.
- **Principais Classes**:
  - `LocalDate`: Representa uma data (ano, mês, dia) sem hora.
  - `LocalTime`: Representa um horário (hora, minuto, segundo, nanossegundo) sem data.
  - `LocalDateTime`: Combina data e hora.
  - `ZonedDateTime`: Representa uma data e hora com fuso horário.
  - `Period` e `Duration`: Representam a quantidade de tempo entre duas datas ou duas horas.

#### Explicação Detalhada

1. **LocalDate**:
   - Representa uma data sem horário. Útil para situações onde o tempo do dia não é relevante.
   - **Métodos Comuns**:
     - `now()`: Obtém a data atual.
     - `of(int year, int month, int dayOfMonth)`: Cria uma data específica.
     - `parse(CharSequence text)`: Converte uma string em uma data.
     - `plusDays(long daysToAdd)`, `minusDays(long daysToSubtract)`: Adiciona ou subtrai dias.
   - **Exemplo**:
     ```java
     LocalDate today = LocalDate.now();
     LocalDate specificDate = LocalDate.of(2024, Month.DECEMBER, 25);
     LocalDate parsedDate = LocalDate.parse("2024-12-25");
     System.out.println("Today: " + today);
     System.out.println("Specific Date: " + specificDate);
     System.out.println("Parsed Date: " + parsedDate);
     ```

2. **LocalTime**:
   - Representa um horário sem data. Útil para situações onde a data não é relevante.
   - **Métodos Comuns**:
     - `now()`: Obtém o horário atual.
     - `of(int hour, int minute, int second)`: Cria um horário específico.
     - `parse(CharSequence text)`: Converte uma string em um horário.
     - `plusHours(long hoursToAdd)`, `minusMinutes(long minutesToSubtract)`: Adiciona ou subtrai horas e minutos.
   - **Exemplo**:
     ```java
     LocalTime now = LocalTime.now();
     LocalTime specificTime = LocalTime.of(14, 30, 0);
     LocalTime parsedTime = LocalTime.parse("14:30:00");
     System.out.println("Now: " + now);
     System.out.println("Specific Time: " + specificTime);
     System.out.println("Parsed Time: " + parsedTime);
     ```

3. **LocalDateTime**:
   - Combina data e horário sem fuso horário. Útil para representar eventos que ocorrem em um ponto específico no tempo.
   - **Métodos Comuns**:
     - `now()`: Obtém a data e horário atuais.
     - `of(int year, int month, int dayOfMonth, int hour, int minute, int second)`: Cria uma data e horário específicos.
     - `parse(CharSequence text)`: Converte uma string em uma data e horário.
   - **Exemplo**:
     ```java
     LocalDateTime current = LocalDateTime.now();
     LocalDateTime specificDateTime = LocalDateTime.of(2024, Month.DECEMBER, 25, 14, 30, 0);
     LocalDateTime parsedDateTime = LocalDateTime.parse("2024-12-25T14:30:00");
     System.out.println("Current: " + current);
     System.out.println("Specific DateTime: " + specificDateTime);
     System.out.println("Parsed DateTime: " + parsedDateTime);
     ```

4. **ZonedDateTime**:
   - Representa uma data e hora com fuso horário. Útil para aplicações que precisam considerar fusos horários.
   - **Métodos Comuns**:
     - `now()`: Obtém a data e hora atuais com o fuso horário.
     - `of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond, ZoneId zone)`: Cria uma data e hora específicos com fuso horário.
     - `parse(CharSequence text)`: Converte uma string em uma data e hora com fuso horário.
   - **Exemplo**:
     ```java
     ZonedDateTime zdt = ZonedDateTime.now();
     ZonedDateTime specificZonedDateTime = ZonedDateTime.of(2024, 12, 25, 14, 30, 0, 0, ZoneId.of("America/New_York"));
     ZonedDateTime parsedZonedDateTime = ZonedDateTime.parse("2024-12-25T14:30:00-05:00[America/New_York]");
     System.out.println("ZonedDateTime: " + zdt);
     System.out.println("Specific ZonedDateTime: " + specificZonedDateTime);
     System.out.println("Parsed ZonedDateTime: " + parsedZonedDateTime);
     ```

5. **Period e Duration**:
   - `Period`: Representa uma quantidade de tempo em anos, meses e dias. Usado para calcular a diferença entre duas datas.
   - `Duration`: Representa uma quantidade de tempo em segundos e nanossegundos. Usado para calcular a diferença entre dois horários.
   - **Exemplo de Period**:
     ```java
     LocalDate startDate = LocalDate.of(2024, Month.JANUARY, 1);
     LocalDate endDate = LocalDate.of(2024, Month.DECEMBER, 31);
     Period period = Period.between(startDate, endDate);
     System.out.println("Period: " + period.getYears() + " years, " + period.getMonths() + " months, " + period.getDays() + " days");
     ```
   - **Exemplo de Duration**:
     ```java
     LocalTime startTime = LocalTime.of(9, 0);
     LocalTime endTime = LocalTime.of(17, 0);
     Duration duration = Duration.between(startTime, endTime);
     System.out.println("Duration: " + duration.toHours() + " hours, " + duration.toMinutes() % 60 + " minutes");
     ```

6. **DateTimeFormatter**:
   - Utilizado para formatação e análise de datas e horas.
   - **Métodos Comuns**:
     - `ofPattern(String pattern)`: Cria um formatador com o padrão especificado.
     - `format(TemporalAccessor temporal)`: Formata a data/hora para uma string.
     - `parse(CharSequence text)`: Converte uma string em uma data/hora.
   - **Exemplo**:
     ```java
     LocalDateTime now = LocalDateTime.now();
     DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");
     String formattedDateTime = now.format(formatter);
     System.out.println("Formatted DateTime: " + formattedDateTime);

     String dateStr = "25/12/2024 12:30:00";
     LocalDateTime parsedDateTime = LocalDateTime.parse(dateStr, formatter);
     System.out.println("Parsed DateTime: " + parsedDateTime);
     ```

#### Exemplo Completo

**Objetivo**: Demonstrar a manipulação de datas e horas usando a API de data/hora do Java SE 8.

```java
import java.time.*;
import java.time.format.DateTimeFormatter;

public class DateTimeExample {
    public static void main(String[] args) {
        // LocalDate example
        LocalDate today = LocalDate.now();
        LocalDate specificDate = LocalDate.of(2024, Month.DECEMBER, 25);
        LocalDate parsedDate = LocalDate.parse("2024-12-25");
        System.out.println("Today: " + today);
        System.out.println("Specific Date: " + specificDate);
        System.out.println("Parsed Date: " + parsedDate);

        // LocalTime example
        LocalTime now = LocalTime.now();
        LocalTime specificTime = LocalTime.of(14, 30, 0);
        LocalTime parsedTime = LocalTime.parse("14:30:00");
        System.out.println("Now: " + now);
        System.out.println("Specific Time: " + specificTime);
        System.out.println("Parsed Time: " + parsedTime);

        // LocalDateTime example
        LocalDateTime current = LocalDateTime.now();
        LocalDateTime specificDateTime = LocalDateTime.of(2024, Month.DECEMBER, 25, 14, 30, 0);
        LocalDateTime parsedDateTime = LocalDateTime.parse("2024-12-25T14:30:00");
        System.out.println("Current: " + current);
        System.out.println("Specific DateTime: " + specificDateTime);
        System.out.println("Parsed DateTime: " + parsedDateTime);

        // ZonedDateTime example
        ZonedDateTime zdt = ZonedDateTime.now();
        ZonedDateTime specificZonedDateTime = ZonedDateTime.of(2024, 12, 25, 14, 30, 0, 0, ZoneId.of("America/New_York"));
        ZonedDateTime parsedZonedDateTime = ZonedDateTime.parse("2024-12-25T14:30:00-05:00[America

```java
        ZonedDateTime zdt = ZonedDateTime.now();
        ZonedDateTime specificZonedDateTime = ZonedDateTime.of(2024, 12, 25, 14, 30, 0, 0, ZoneId.of("America/New_York"));
        ZonedDateTime parsedZonedDateTime = ZonedDateTime.parse("2024-12-25T14:30:00-05:00[America/New_York]");
        System.out.println("ZonedDateTime: " + zdt);
        System.out.println("Specific ZonedDateTime: " + specificZonedDateTime);
        System.out.println("Parsed ZonedDateTime: " + parsedZonedDateTime);

        // Period example
        LocalDate startDate = LocalDate.of(2024, Month.JANUARY, 1);
        LocalDate endDate = LocalDate.of(2024, Month.DECEMBER, 31);
        Period period = Period.between(startDate, endDate);
        System.out.println("Period: " + period.getYears() + " years, " + period.getMonths() + " months, " + period.getDays() + " days");

        // Duration example
        LocalTime startTime = LocalTime.of(9, 0);
        LocalTime endTime = LocalTime.of(17, 0);
        Duration duration = Duration.between(startTime, endTime);
        System.out.println("Duration: " + duration.toHours() + " hours, " + duration.toMinutes() % 60 + " minutes");

        // DateTimeFormatter example
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");
        String formattedDateTime = now.format(formatter);
        System.out.println("Formatted DateTime: " + formattedDateTime);

        String dateStr = "25/12/2024 12:30:00";
        LocalDateTime parsedDateTime = LocalDateTime.parse(dateStr, formatter);
        System.out.println("Parsed DateTime: " + parsedDateTime);
    }
}
```

**Exercícios**:
1. **Calcular Idade**: Criar um programa que calcula a idade de uma pessoa baseada na data de nascimento usando `Period`.
2. **Formatar Datas**: Desenvolver um programa que formata datas em diferentes padrões usando `DateTimeFormatter`.
3. **Fuso Horário**: Escrever um programa que converte a data e hora atual para diferentes fusos horários usando `ZonedDateTime` e `ZoneId`.
4. **Intervalos de Tempo**: Implementar um programa que calcula a duração entre dois horários em horas e minutos usando `Duration`.
5. **Operações com Datas e Horas**: Criar um programa que adiciona e subtrai dias, meses e anos de uma data específica utilizando `LocalDate` e `Period`.

